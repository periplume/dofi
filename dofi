#!/usr/bin/env bash
# file: dofi
# description: dotfile manager
# source: https://github.com/periplume/dofi.git
# copyright (c) 2024 Jason Lindemuth <jason@bloom.us>
# licensed under GPL-3.0-or-later

# STRICT (SAFE) SCRIPT AND SHELL SETTINGS
set -o errexit
set -o nounset
set -o pipefail
IFS=$'\n\t' 

# DEBUG OVERRIDE (uncomment to force enable _DEBUG)
#_DEBUG=true

# REQUIREMENTS
hash git || { echo 'ERROR: git is required'; return 1; }

# DESCRIPTION
_printDescription () {
	cat << EOF
dofi is a single bash script designed to manage user dotfiles using
the git bare-repo method. it can be used, of course, to bring any
files under local git control.

the installation and interface is intended for users without prior
knowledge of git, although it does not preclude expert git users.

for data redundancy, it provides an easy to follow procedure to
set up a remote repo to which to replicate (github only now).

the code style sacrifices brevity for clarity; it aims to be
robust, fail-safe and easy to read. it also aims to be 
self-documenting and self-building. for more info, consult
the _build() function within.

# inspired by https://news.ycombinator.com/item?id=11070797
# and https://www.atlassian.com/git/tutorials/dotfiles
EOF
}

# USAGE
_printHelp () {
	cat << EOF
usage: dofi [GLOBAL OPTIONS] <command> [COMMAND OPTIONS]

summary: preserve, protect, and revision your personal files

global options:
 -h       print help
 -d       print debug messages
 -v       print version

commands:
 add <file>       add file to the dotfile repo
 remove <file>    remove a file from the repo
 save             commit and push to the remote
 status           print summary of file and syncronization status
 attach           attach a new remote repo to push to
 connect          connect and pull from an existing dofi repo
 install          install dofi script and create local repo
 version          print script version details
note: use -h to for specific command options (eg 'attach -h')

note: git commands may be used directly, eg:
$ dofi git status
EOF
# note: ideal height <24 lines (eg gnome default term size is 24x80)
}

_printVersionOptions () {
	cat << EOF
usage: dofi version [OPTIONS]

summary: print version information

build options:
 -h               print version usage
 -c               check for updates
 -v               verbose
 -b               print the build hash
EOF
}

_printInstallOptions () {
	cat << EOF
usage: dofi install [OPTIONS]

summary: copy the script into the designated PATH location

install options:
 -h               print install usage
 -l               use ~/.local/bin              [default]
 -b               use ~/bin
 -u               update PATH in .bashrc        [default reports only]
 -d               do not create local dofi repo [default creates]
 -s <path>        specify location
EOF
}

_printAttachOptions () {
	cat << EOF
usage: dofi attach [OPTIONS]

summary: add a remote repo, optionally creates the remote
on supported git hosting platforms

attach options:
 -h               print attach usage
 -p <platform>    remote platform <platform>
                    [tested platforms: github]
 -c               create the remote repo
                    [supported platform: github]
                    [requires gh cli]
 -s               use ssh protocol
                    [default is https]
 -e               use empty ssh key passphrase
                    [default is to prompt for a passphrase]
 -n <name>        specify the remote repo name
                    [default is 'dotdofi']
EOF
} 

# CONSOLE COLORIZING FUNCTIONS
# these functions provide (mostly) uniform status messages
# they take one argument (a string) and are called so:
# _info "the operation was a success"
# TODO normalize the ASCII escape code format type
#
# use _ask for prompting for y/n and data input (does not newline)
# use read to read the input in
# yellow bg and black text -without- newline
_ask() {
	printf "\033[38;5;5;48;5;82mUSER\033[0m %s" "$1"
# note: echo required after read from _ask in order to format 
# the lines correctly (a minor annoyance I have't fixed)
}
# use to call attention to something user must do
# yellow bg and black text -with- newline 
_note() {
	printf "\033[38;5;0;48;5;11mNOTE\033[0m %s\n" "$1"
}
# use for high danger prompt
# red bg with blinking white text
_danger() {
	printf "\033[5;97;41mNOTE\033[0m %s\n" "$1"
}
# use to report on normal results or activity
# black bg and green text with newline
_info() {
	printf "\033[38;5;2mINFO\033[0m %s\n" "$1"
}
# use to warn about unusual but non-fatal results or conditions
# black bg and yellow text with newline
_warn() {
	printf "\033[38;5;11mWARN\033[0m %s\n" "$1"
}
# use to report details of fatal errors
# black bg and bold red text with newline
_error() {
	printf "\033[38;5;9mERROR\033[0m %s\n" "$1"
}
# use to print detailed debug statements (when _DEBUG=true)
# black bg and cyan text with newline
_debug() {
	[ ${_DEBUG:-false} = "false" ] || printf "\033[38;5;6mDEBUG\033[0m %s\n" "$1"
}

# these functions are used to add color to text based on data type, eg:
# _ask "enter path [$(_fmt path "${_pathname}")] "
# will format the variable $_pathname into yellow text on black bg
_fmt() {
	# arg 1 = specify the kind of thing to format
	# arg 2 = the string to be formatted (must be "quoted message")
	# print a path in yellow
	[[ $1 = "path" ]] && printf "\033[93;40m%s\033[0m\n" "$2"
	# print an email address in yellow
	[[ $1 = "email" ]] && printf "\033[38;5;11m%s\033[0m\n" "$2"
	# print a command name in green
	[[ $1 = "cmd" ]] && printf "\033[38;5;2m%s\033[0m\n" "$2"
	# print an url in bright cyan
	[[ $1 = "url" ]] && printf "\033[38;5;87m%s\033[0m\n" "$2"
	# print white text on green bg (eg like a github.com button)
	[[ $1 = "button" ]] && printf "\033[97;42m%s\033[0m\n" "$2"
	# print black text on a grey background (eg like keyboard keys)
	[[ $1 = "key" ]] && printf "\033[30;47m%s\033[0m\n" "$2"
	# print bright magenta text for special names
	[[ $1 = "name" ]] && printf "\033[1;95;40m%s\033[0m\n" "$2"
}

# PARAMETER PROCESSING
_getOpts () {
	 # preserve and export the initial positional parameters
	export _allParams="${@}"
	local OPTIND
	while getopts ":hvd" flag ; do
		case ${flag} in
			h)
				_printHelp; exit 0
				;;
			v)
				# a hacky method to short-circuit normal initialization
				_subCommandParams=
				_setEnv; _version; exit 0
				;;
			d)
				# we want this to propagate
				export _DEBUG=true
				_debug "enabled debug messages"
				;;
			?)
				_error "invalid global option: -${OPTARG}"; exit 1
				;;
		esac
	done
	# reset positional parameters before reading the subcommand 
	shift $((OPTIND - 1)); OPTIND=1
	# preserve and export the subcommand with its parameters
	export _subCommandParams="${@}"
	# look for the subcommand and read its options
	while ((${#})); do
		case ${1} in
			help)
				_printHelp; exit 0
				;;
			version)
				_subCommand=$1; shift
				while getopts ":hcvb" flag; do
					case ${flag} in
						h)
							_printVersionOptions; exit 0
							;;
						c)
							_versionCHECK=true
							;;
						v)
							_versionVERBOSE=true
							;;
						b)
							_printBUILDHASH=true
							;;
					esac
				done
				return
				;;
			inspect)
				# unpublished expert command
				#TODO add flag for developer to view dofi repo
				_subCommand=$1; shift
				return
				;;
			add)
				_subCommand=$1; shift
				return
				;;
			remove)
				_subCommand=$1; shift
				return
				;;
			save)
				_subCommand=$1; shift
				return
				;;
			status)
				_subCommand=$1; shift
				while getopts ":v" flag; do
					case ${flag} in
						h)
							_printStatusOptions; exit 0
							;;
						v)
							_statusVERBOSE=true
							;;
					esac
				done
				return
				;;
			install)
				_subCommand=$1; shift
				while getopts ":hbluds:" flag; do
 					case ${flag} in
						h)
							_printInstallOptions; exit 0
							;;
						b)
							_useHOMEBIN=true
							;;
						l)
							_useDOTLOCALBIN=true
							;;
						u)
							_updatePATH=true
							;;
						d)
							_createDOFI=false
							;;
						s)
							# -s option argument (OPTARG) must not be a flag
							if [ "${OPTARG:0:1}" = "-" ] ; then
								_error "'${_subCommand} -${flag}' requires an argument that is not a flag '${OPTARG}'"
								_printInstallOptions; exit 1
							fi
							_usePATH="${OPTARG}"
							_debug "intent: use path '${_usePATH}'"
							;;
						:)
							_error "'${_subCommand} -${OPTARG}' requires an argument"
							_printInstallOptions; exit 1
							;;
						\?)
							_error "unknown option '-${OPTARG}'"
							_printInstallOptions; exit 1
							;;
					esac
				done
				# discard the processed options
				shift $((OPTIND-1))
				# now check for "help" or other spurious arguments
				if [[ ! -z ${1:-} ]]; then
					_warn "spurious argument: ${1}"
					_printInstallOptions; exit 1
				fi
				return
				;;
			attach)
				_subCommand=$1; shift
				while getopts ":hp:n:cse" flag; do
					case ${flag} in
						h)
							_printAttachOptions; exit 0
							;;
						p)
							# the remote platform (required)
							# -p option argument (OPTARG) must not be a flag
							if [ "${OPTARG:0:1}" = "-" ] ; then
								_error "-p requires an argument that is not a flag '${OPTARG}'"
								_printAttachOptions; exit 1
							fi
							_remotePLATFORM="${OPTARG}"
							_debug "intent: attach remote '${_remotePLATFORM}'"
							;;
						n)
							# alternate name for remote repo name
							# -n option argument (OPTARG) must not be a flag
							if [ "${OPTARG:0:1}" = "-" ] ; then
								_error "-n requires an argument that is not a flag '${OPTARG}'"
								_printAttachOptions; exit 1
							fi
							_remoteNAME="${OPTARG}"
							_debug "intent: attach remote name: '${_remoteNAME}'"
							;;
						c)
							# create the remote repo
							_debug "intent: create the remote repo (_attachCreate=true)"
							_attachCreate=true
							;;
						s)
							# use ssh (instead of the default https)
							_debug "intent: use ssh protocol (_useSSH=true)"
							_useSSH=true
							;;
						e)
							_debug "intent: disable ssh key passphrase option (_sshPassphrase=false)"
							_sshPassphrase=false
							;;
						:)
							_error "'${_subCommand} -${OPTARG}' requires an argument"
							_printAttachOptions; exit 1
							;;
						\?)
							_error "unknown option '-${OPTARG}'"
							_printAttachOptions; exit 1
							;;
					esac
				done
				# discard the processed options
				shift $((OPTIND-1))
				# now check for "help" or other spurious arguments
				if [[ ! -z ${1:-} ]]; then
					_warn "spurious argument: ${1}"
					_printAttachOptions; exit 1
				fi
				return
				;;
			build)
				# run the build script (consult _build for more info) 
				_subCommand=$1; shift
				return
				;;
			create)
				_subCommand=$1; shift
				return
				;;
			connect)
				_subCommand=$1; shift
				return
				;;
			git)
				# set the git passthrough switch true
				_gitPASSTHROUGH=true
				# the subcommand is 'git' and will execute _git
				_subCommand=$1
				shift
				# collect all the parameters (commands) after git
				_gitCommand=("${@}")
				# notice we use an array to avoid quoting problems
				_debug "the subcommand is a raw ${_subCommand} command"
				_debug "the git command is [${_gitCommand}]"
				return
				;;
			*)
				_error "'${1}' is not a recognized command; run 'dofi help' for usage"
				exit 1
				;;
		esac
		shift
	done
}

# SUBCOMMAND FUNCTIONS

# 
_inspect () {
	# "expert" command not published in usage
	# if tig exists, use tig, otherwise, use 'git log'
	if hash tig >/dev/null 2>&1; then
		tig -C "${_DOFIHOME}"
	else
		_git log
	fi
}

_add () {
	_file=$1
	_git add $_file
}

# print status info
_status () {
	if [ -d "${_DOFIHOME}" ]; then
		_info "dofi is installed in ${_DOFIHOME}"
	else
		_error "dofi is not installed"
	fi
	if [[ ${_statusVERBOSE:-} = "true" ]]; then
		_info "created by: $(_git --no-pager log -1 --pretty=format:%an%n)"
		_info "created: $(_git --no-pager log -1 --pretty=format:%cr%n)"
		_info "created on: $(_git --no-pager log -1 --pretty=format:%cD%n)"
		_info "current time: $(date)"
		_info "genesis signature: $(cat ${_DOFIHOME}/description)"
		_info "tracked files: $(_git ls-files | grep -v 'README.md' | wc -l) (excluding README.md)"
		_info "commit count: $(_git rev-list --count HEAD)"
		_info "object count: $(_git count-objects --human)"
		_info "current branch: $(_git rev-parse --abbrev-ref HEAD)"
		_info "branch count: $(_git --no-pager branch | wc -l)"
	fi
}

# ATTACH a remote
_attach () {
	# main entry for attach
	# to be run -after- create
	# attach an empty remote repo on <platform>
	# add as a remote for push and pull
	# optionally, create the remote repo first
	# creates ssh keys and github authentication tokens
	#
	# set the remote name first
	local _remoteNAME="${_remoteNAME:-dotdofi}"
	# if there is no local yet, warn, offer to create, or exit
	if [ ! -d "${_DOFIHOME}" ]; then
	 	_warn "${_DOFIHOME} does not exist"
		_ask "create now? [y/n] "
		read -rn1 _yn
		if [[ ${_yn} = "n" ]]; then
			_info "run 'dofi create' first"; exit 1
		elif [[ ${_yn} = "y" ]]; then
			dofi create >/dev/null 2>&1 || { _error "failed"; exit 1; }
			echo
		fi
	fi
	# make sure remote has been specified
	[[ -z "${_remotePLATFORM:-}" ]] && { _error "remote platform must be specified"; exit 1; }
	# set the proper hostname
	case ${_remotePLATFORM} in
		github)
			# set the proper hostname
			_remoteHOST="github.com"
			;;
		dummy)
			_remoteHOST="dummy.com"
			;;
	esac
	# get the remote user name
	_ask "enter the user name for $(_fmt name ${_remotePLATFORM}): "
	read -re _remoteUSERNAME
	if [[ -z ${_remoteUSERNAME} ]]; then
		echo; _error "username required to set up ${_remotePLATFORM}"
			exit 1
	fi
	# set the git url
	if [[ ${_useSSH:-} = true ]]; then
		# set the url for ssh
		_dofiREMOTE="git@${_remoteHOST}:${_remoteUSERNAME}/${_remoteNAME}.git"
		_info "git ssh url: $(_fmt url git@${_remoteHOST}/${_remoteUSERNAME}/${_remoteNAME}.git)"
	else
		# set the url for https
		_dofiREMOTE="https://${_remoteHOST}/${_remoteUSERNAME}/${_remoteNAME}.git"
		_info "git https url: https://${_remoteHOST}/${_remoteUSERNAME}/${_remoteNAME}.git"
	fi
	# if _attachCreate=true, check if the desired platform is supported
	if [[ ${_attachCreate:-} = "true" ]]; then
		_debug "running _attachCreate"
		_attachCreate || { _error "_attachCreate failed"; exit 1; }
	fi
}

# create a remote to attach
# TODO allow --private to create private
_attachCreate () {
	# create the remote repo
	# the list of supported platforms for create
	local _supportedPlatforms=( github dummy )
	# check if the specified platform is supported
	if [[ " ${_supportedPlatforms[*]} " =~ (^|[[:space:]])${_remotePLATFORM}($|[[:space:]]) ]]; then
		_info "remote platform $(_fmt name ${_remotePLATFORM}) is supported"
	else
		_warn "supported platforms include: $(printf '%s ' ${_supportedPlatforms[@]})"
		_error "remote $(_fmt name ${_remotePLATFORM}) is NOT a supported platform for create"
		_printAttachOptions; exit 1
	fi
	# make sure we have the required cli commands
	case ${_remotePLATFORM} in
		github)
			_debug "checking for github 'gh' cli tool"
			if ! hash gh 2>/dev/null; then
			 	_warn "github cli 'gh' is missing and required"
				_ask "install github cli? [y/n]"
				read -rsn1 _yn
      	if [[ ${_yn} = "n" ]]; then
					echo # have not figured out how to structure this to avoid having to use echo
					_warn "see: https://github.com/cli/cli/blob/trunk/docs/install_linux.md"
					_error "github cli required for create (-c) function of attach"
					exit 1
				elif [[ ${_yn} = "y" ]]; then
					echo # have not figured out how to structure this to avoid having to use echo
					_checkSudo || { _warn "sudo required to install github cli;" exit 1; }
					_installGithubCLI || { _error "gh install failed"; exit 1; }
				else
					echo; _error "aborted"
				fi
			else
				_debug "github cli ($(gh --version | head -1)) is in the path"
			fi
			;;
		dummy)
			_error "dummy is a placeholder"
			exit 1
			;;
		*)
			_debug "${_remotePLATFORM} is not supported"; exit 1
			;;
	esac
	# run the designated create function
	if [[ ${_useSSH:-} = true ]]; then
		_createSSH || { _error "_createSSH failed"; return 1; }
	else
		_createHTTPS || { _error "https create failed"; return 1; }
	fi
}

# sub-routine for create for ssh
_createSSH () {
	_debug "checking for ssh-agent"
	_checkSSHAgent || { _error "we rely on ssh-agent for key management"; exit 1; }
	_debug "generating ssh keys; _sshPassphrase=${_sshPassphrase:-false}"
	_generateSSHKeys || { _error "user aborted new key generation"; exit 1; }
	_debug "new ssh keys generated successfully"
	_debug "private (secret) key: ${_privKEYPATH}"
	_debug "public key: ${_pubKEYPATH}"
	# add the keys to the ssh-agent now
	_debug "adding the new ssh keys to the ssh-agent"
	ssh-add "${_privKEYPATH}" >/dev/null 2>&1
	if [ $? = 0 ]; then
		_info "new ssh keys successfully added to ssh-agent"
	else
		_error "keys were not added successfully, aborting"
		return 1
	fi
	_info "testing ssh connection to ${_remoteHOST}"
	# test for known host first...populate .ssh/known_hosts if necessary
	if [ -z "$(ssh-keygen -F ${_remoteHOST} >/dev/null 2>&1)" ]; then
		_debug "not a known host, adding it to known_hosts file now"
		ssh-keyscan -H ${_remoteHOST} >> ~/.ssh/known_hosts 2>/dev/null
		_sshScan=$?
		if [[ $_sshScan = 0 ]]; then
			_debug "'ssh-keyscan -H ${_remoteHOST}' succeeded; known_hosts updated"
		else
			_warn "'ssh-keyscan -H ${_remoteHOST}' failed"
			return 1
		fi
	fi
	_info "ssh connection to ${_remoteHOST} is available"
	# try to clip for easy paste
	if _clip "${_pubKEYPATH}"; then
		_keyClipped=true
		_note "the key has been copied into the clipboard"
	else
		# cannot use any clipboard facillity, instruct user manually
		_note "you must now use a browser to add your public key to $(_fmt url ${_remoteHOST})"
		_note "public key: $(_fmt path ${_pubKEYPATH})"
	fi
	_note "now paste the ssh public key into $(_fmt url ${_remoteHOST})"
	# print help function for while loop
	_printPasteHelp () {
		_note "for detailed steps, press $(_fmt key 'h') for help"
		_note "to view the public key in this terminal, press $(_fmt key 'p') to print"
		_note "press $(_fmt key 't') to test if the key has been added successfully"
		_ask "to abort this operation, press $(_fmt key a) : "
	}
	# test SSH connection function for while loop
	_testSSH () {
		_info "testing ssh connectivity and authentication to ${_remoteHOST}"
		ssh -T git@github.com >/dev/null 2>&1
		_testResult=$?
		if [ ${_testResult} = 1 ]; then
			_info "ssh test to ${_remoteHOST} SUCCESS with code '${_testResult}'"
			return
		else
			_error "ssh test to ${_remoteHOST} FAILED with error code '${_testResult}'"
			_note "did you add the key to ${_remoteHOST}?"
			return 1
		fi
	}
	_printPasteHelp
	while read -rsn1 _confirm; do
		if [ "${_confirm:-}" = "a" ]; then
			echo; _warn "user aborted"
			_note "the ssh keys were created and left in place"
			return 1
		elif [ "${_confirm:-}" = "h" ]; then
			echo
			_note "first, log on to your $(_fmt url ${_remoteHOST}) account"
			_note "next, click top right profile icon, then click Settings"
			_note "click 'SSH and GPG Keys' link on left"
			_note "click green button: $(_fmt button 'New SSH Key')"
			_note "give it a meaningful title, such as corresponds to the key name:"
			_note "  $(_fmt path ${_privKEYNAME})"
			_note "paste the 'Authentication' key into the 'Key' dialog box"
			_note "finally, press the green button: $(_fmt button 'Add SSH Key')"	
			_note "to view the key in this terminal, press $(_fmt key 'p') to print"
			_note "press $(_fmt key 't') to test if the key has been added successfully"
			_ask "to abort this operation, press $(_fmt key a) : "
		elif [ "${_confirm:-}" = "p" ]; then
			echo; cat "${_pubKEYPATH}"
			_info "copy and paste this key ^^^ above into $(_fmt url ${_remoteHOST})" 
			_ask "press $(_fmt key t) to test if the authentication key has been added "
		elif [ "${_confirm:-}" = "t" ]; then
			echo
			_testSSH && break
		fi
	done
	_info "success, the ssh key is working"
	# next we must create an authentication token and add it to the github
	_info "next we must generate an authentication token"
	# cli authentication setup
	_note "first, log on to your $(_fmt url ${_remoteHOST}) account"
	_note "next, click top right profile icon, then click Settings"
	_note "click 'Developer Settings' link on the bottom left"
	_note "click 'Personal access tokens' link on the bottom left"
	_note "select 'Tokens (classic)' and then click the 'Generate new token' button"
	_note "select 'Generate new token (classic)'"
	_note "give it a name that corresponds to the ssh public key:"	
	_note "  $(_fmt path dofi-${_USERNAME}-${_selfHOST}-${_remotePLATFORM}-${_remoteUSERNAME})"
	_note "change the 'Expiration' to 'No expiration'"
	_note "select the 'repo' group"
	_note "select the 'admin:org' group"
	_note "press the $(_fmt button 'Generate token') button"
	_note "copy the token to the clipboard and..."
	# clever method from https://stackoverflow.com/questions/1923435
	prompt=$(_ask "paste token here: ")
	unset _pat
	while IFS= read -p "$prompt" -r -s -n1 char; do
		if [[ $char == $'\0' ]]; then
			break
		fi
		prompt='*'
		_pat+="$char"
	done
	echo "${_pat}" | gh auth login -p ssh -h github.com --with-token
	gh auth status
	gh repo create --public -d "$(cat ${_DOFIHOME}/description)" "${_remoteNAME}"
	_git remote add remote-primary ${_dofiREMOTE}
	_git push --set-upstream remote-primary main
	_git push -u remote-primary
	exit 0
}

# sub-routine for create for https
_createHTTPS () {
	echo TODO
}

# here we store the version info in an assoc array
declare -A _versionDATA
_getVERSION () {
_versionDATA[_currentHASH]=fb8ef6adbe393f48dbb74225a5803cec88f639af
_versionDATA[_releaseVERSION]=
}

_version () {
	# get the current version info
	# TODO extend this to serve dual purpose: version of dofi script and version
	# of dotdofi file set
	# first, just the dofi script itself
	_getVERSION
	local _currentHASH="${_versionDATA[_currentHASH]}"
	local _releaseVERSION="${_versionDATA[_releaseVERSION]}"
	# next, check for developer status
	_getREPO
	_dofiLOCAL="${_repoLOCATION[_local]}"
	_dofiREMOTE="${_repoLOCATION[_remoteHTTPS]}"
	# for scripting...the -b switch outputs the build hash only
	if [[ "${_printBUILDHASH:-}" = "true" ]]; then
		# print the _versionDATA[_currentHASH] value and exit
		echo "${_currentHASH}"
		exit
	fi
	# only print the currentVERSION hash if verbose is not true
	if [[ ${_versionVERBOSE:-} != "true" ]]; then
		echo "dofi : ${_releaseVERSION:-beta} : ${_currentHASH:0:7}"
	elif [[ ${_versionCHECK:-} = "true" ]]; then
		# compare _currentVERSION with canonical "hash.."
		# if match, version is current
		# if no match, check for last common ancestor and compute how many
		# "versions" this script is behind the canonical and report
		echo TODO
	else
		# print verbose version info
		echo "dofi : ${_releaseVERSION:-beta} : ${_currentHASH:0:7}"
		# print canonical source
		echo "source: https://github.com/periplume/dofi.git"
		# print commit date
		[[ ! -z ${_currentHASH:-} ]] && _commitDATE=$(git -C "${_dofiLOCAL}" show --no-patch --no-notes --pretty='%cd' ${_currentHASH})
		echo "commit date: ${_commitDATE:-none}"
		# if possible, compare with canonical
		echo "ls-remote comparison"
		echo "listed remotes"
	fi
	return
}

_build () {
	# developer feature
	# requires ENV VAR: _dofiDEVELOPER=true
	# requires setting the path to the local repo here:
	_dofiREPO="${HOME}/lab/dofi"
	# don't do anything unless user has explicitly enabled DEVELOPER mode
	[[ ! ${_dofiDEVELOPER:-} = "true" ]] && \
		{ _error "'build' is not valid: read the source for more info"; exit 1; }
	# use exec to run the dofi.build in the local repo
	_debug "using 'exec' to run the build script"
	exec "${_dofiREPO}/build/dofi.build" "${@}"
}

# create a local repo function
_create () {
	#  TODO
	#  create should add the dofi script to the repo
	#  the sequence:
	#  add the README first and make the first commit
	#  add the commit hash from the first as version to dofi script
	#  commit that file...thus the dofi script has a hash as version
	#  two kinds:
	#  1. user install: add to the script the source hash (default)
	#  2. developer build: add to the latest script the hash (-b build)
	#  i fear i am over-complicating this...but lets see
	#  break README into _makeREADME func
	#  we want a user README to be useful to the user
	#  we want the public git repo README useful to the potential user
	# TODO
	# install should create a README depending on
	# 1. a build...readme should include install instructions
	# 2. a user...readme should include description and basic instructions/usage
	#
	# create a new dofi local bare repo for dotfiles
	# use "main" as the initial branch
	# first check that there is no such repo
	[ -d "${_DOFIHOME}" ] && { _warn "${_DOFIHOME} already exists"; exit 1; }
	# first work out git user name and email
	if [ -e "$HOME/.gitconfig" ]; then
		# user has a git config file, we will check it for NAME and EMAIL
		_debug "user has a config file"
  	# determine user's full name and email from git if possible
  	git config --global --get user.name 1>/dev/null \
		&& _gitUSERFULLNAME=$(git config --global --get user.name)
		git config  --global --get user.email 1>/dev/null \
    && _gitUSEREMAIL=$(git config --global --get user.email)
		# in case we got nothing, do our best
		[ -z "${_gitUSEREMAIL:-}" ] && _gitUSEREMAIL="unknown"
		[ -z "${_gitUSERFULLNAME:-}" ] && _gitUSERFULLNAME=$USER
	else
		# user has no git config file
		_debug "user has no gitconfig file...we must ask for details"
		# first try for the user full name from /etc/passwd
		_userRecord="$(getent passwd $USER)"
		_userGecosField="$(echo "$_userRecord" | cut -d ':' -f 5)"
		_userFullName="$(echo "$_userGecosField" | cut -d ',' -f 1)"
		if [[ -z ${_userFullName:-} ]]; then
			_gitUSERFULLNAME="$USER"
		else
			_gitUSERFULLNAME="${_userFullName}"
		fi
		_ask "enter preferred (full) user name [$(_fmt name ${_gitUSERFULLNAME})] "
		read _preferredNAME
		[ -z ${_preferredNAME} ] || _gitUSERFULLNAME=${_preferredNAME}
		_gitUSEREMAIL=unknown
		_ask "enter user email [$(_fmt name ${_gitUSEREMAIL})] "
		read _preferredEMAIL
		[ -z ${_preferredEMAIL} ] || _gitUSEREMAIL=${_preferredEMAIL}
		# now create a gitconfig
		_debug "creating new .gitconfig file"
		git config --global user.name "${_gitUSERFULLNAME}"
		git config --global user.email "${_gitUSEREMAIL}"
	fi
	# initialize the bare repo
	_debug "initializing the git bare repo at '${_DOFIHOME}'"
	git init --bare --initial-branch=main "${_DOFIHOME}" 1>/dev/null
	# disable file tracking (in this repo only)
	_git config --local status.showUntrackedFiles no
	# put the usage info into README.md surrounded by backticks to render as code
	_debug "building the README.md file"
	echo '```' > "${HOME}/README.md"
	_printHelp >> "${HOME}/README.md"
	echo '```' >> "${HOME}/README.md"
	echo '---' >> "${HOME}/README.md"
	echo '```' >> "${HOME}/README.md"
	_printAttachOptions >> "${HOME}/README.md"
	echo '```' >> "${HOME}/README.md"
	# add and make first commit
	_debug "adding the README.md as the first commit"
	_git add "${HOME}/README.md"
	_git commit -q -m "[genesis] dofi repo created by ${_USERNAME}"
	# finally, put the "installed" marker in the git description file
	_debug "marking a dofi signature into the description file"
	_gitInitial=$(_git rev-parse --short --verify main)
	_time=$(date +%s)
	printf "dofi:${_USERNAME}:${_time}:${_gitInitial}\n" > "${_DOFIHOME}/description"
	_debug "created 'dofi:${_USERNAME}:${_time}:${_gitInitial}'"
	_info "success: use 'dofi help' to get started"
}

# install the script into user path
_install () {
	# assume the script has been downloaded to $HOME somewhere
	# pipe install not allowed (nor can this file be sourced)
	#
	# set up all the various paths, etc	
	local _installPATH
	local _installPATHBASE
	_debug "_usePATH=${_usePATH:-unset}"
	_debug "_useDOTLOCALBIN=${_useDOTLOCALBIN:-unset}"
	_debug "_useHOMEBIN=${_useHOMEBIN:-unset}"
	_debug "_updatePATH=${_updatePATH:-unset}"
	# determine intent first, then determine conditions and actions
	_installFROM=${_selfABSOLUTE}
	_debug "intent: install from self '${_installFROM}'"
	# if _usePATH is not empty, read _usePATH value provided
	if [[ ! -z ${_usePATH:-} ]]; then
		if [[ $(basename ${_usePATH}) = "dofi" ]]; then
			# user specified the FULL path (we assume)
			_installPATH=${_usePATH}
			_debug "intent: install as '${_installPATH}'"
		elif [[ "${_usePATH: -1}" = "/" ]]; then
			# user added trailing '/' signifying a dir
			_installPATH="${_usePATH}dofi"
			_debug "intent: install as '${_installPATH}'"
		else
			# user specified a basedir (without trailing '/')
			_installPATH="${_usePATH}/dofi"
			_debug "intent: install as '${_installPATH}'"
		fi
	# if _useDOTLOCALBIN is true, just use _useDOTLOCALBIN
	elif [[ ${_useDOTLOCALBIN:-} = "true" ]]; then
		_installPATH="$HOME/.local/bin/dofi"
		_debug "intent: install as '${_installPATH}'"
	# if _useHOMEBIN is true and _useDOTLOCAL is unset, use _useHOMEBIN
	elif [[ ${_useHOMEBIN:-} = "true" ]] && [[ ${_useDOTLOCALBIN:-false} = "false" ]]; then
		_installPATH="$HOME/bin/dofi"
		_debug "intent: install as '${_installPATH}'"
	# if _useHOMEBIN and _useDOTLOCAL are both unset, use _useDOTLOCAL
	# set to _installPATH=undefined and work it out
	elif [[ ${_useHOMEBIN:-false} == "false" ]] && [[ ${_useDOTLOCALBIN:-false} = "false" ]]; then
		#_installPATH="$HOME/.local/bin/dofi"
		#_debug "intent: install as '${_installPATH}'"
		_installPATH=undefined
		_debug "intent: install location undefined"
	fi
	# check if an instance of dofi is already in the PATH somewhere
	# which allows us to determine the destination
	if ! hash dofi 2>/dev/null; then
		# no dofi in the PATH
		_seeDOFI=false
		_debug "condition: dofi is not in the current PATH"
		_doCOPY=true
		if [[ "${_installPATH}" = "undefined" ]]; then
			_installPATH="$HOME/.local/bin/dofi"
			_debug "condition: install at preferred '${_installPATH}'"
		else
			_debug "condition: install at designated: '${_installPATH}'"
		fi
	else
		# there is an existing dofi in the PATH
		_seeDOFI=true
		_debug "condition: dofi is already in the PATH"
		_existingDOFI=$(command -v dofi)
		_debug "condition: dofi exists here: '${_existingDOFI}'"
		if [[ ${_installPATH} = "undefined" ]]; then
			# this is an UPGRADE and user did not specify the destination
			_debug "condition: upgrade"
			_installPATH=${_existingDOFI}
		elif [[ ${_installPATH} != ${_existingDOFI} ]]; then
			# user specified a different destination, will not do this
			_debug "condition: attempting to add second copy to PATH"
			_warn "dofi already exists at '${_existingDOFI}'"
			_warn "attempting to install second instance at '${_installPATH}'"
			_warn "remove existing or modify destination location"
			_error "multiple instances not allowed"
			exit 1
		else
			# user's intent matches the condition
			_debug "condition: '${_installPATH}' matches the existing '${_existingDOFI}'"
		fi
	fi
	# check if this file is attempting to replace itself
	if [[ ${_selfABSOLUTE} = ${_installPATH} ]]; then
		_error "cannot replace self with self"
		_error "are you sure you are editing/executing the correct file?"
		exit 1
	fi
	# now set _installPATHBASE and check directory space
	_installPATHBASE=$(dirname ${_installPATH})
	_debug "condition: install in base dir '${_installPATHBASE}'"
	# examine the intended path
	# is the given path relative or absolute
	if [ "${_installPATHBASE}" != "${_installPATHBASE#/}" ]; then
	 	_debug "condition: given path '${_installPATHBASE}' is absolute"
	else
		# resolve into an absolute path
	 	_debug "condition: given path '${_installPATHBASE}' is relative"
		_debug "condition: given path is relative to '$PWD'"
		_installPATH="$PWD/${_installPATH}"
		_installPATHBASE="$PWD/${_installPATHBASE}"
		_debug "condition: converted base path to absolute '${_installPATHBASE}'"
		_debug "condition: converted path to absolute '${_installPATH}'"
	fi
	# update PATH?
	if [[ ${_updatePATH:-unset} = "true" ]]; then
		_debug "condition: update PATH with '${_installPATHBASE}'"
	else
		_debug "condition: do not update PATH"
	fi
	# next validate the conditions of the environment given the intent
	# validate the existence of the intended base path
	if [[ -d ${_installPATHBASE} ]]; then
		_debug "condition: base dir '${_installPATHBASE}' already exists"
		_doMKDIR=false
	else
		# base path does not exist
		_debug "condition: '${_installPATHBASE}' does not exist"
		_doMKDIR=true
	fi
	# check if desired BASE is already in the PATH
	if [[ ":$PATH:" == *":${_installPATHBASE}:"* ]]; then
		_debug "condition: PATH already includes '${_installPATHBASE}'"
		_needPATH=false
	else
		_debug "condition: current PATH does not include '${_installPATHBASE}'"
		_needPATH=true
	fi
	# check if the existing file matches the intended destination
	if [[ ${_installPATH} = ${_existingDOFI:-} ]]; then
		_debug "condition: attempting to replace existing dofi"
		# check if this file differs from the one it intends to replace
		if cmp --silent "${_selfABSOLUTE}" "${_installPATH}"; then
			_debug "condition: files are identical"
			_doCOPY=false
		else
			_debug "condition: files are NOT identical"
		if [[ ${_selfABSOLUTE} -nt ${_installPATH} ]]; then
			_debug "condtion: '${_selfABSOLUTE}' is newer than '${_installPATH}'"
			_doCOPY=true
			else
				_warn "'${_selfABSOLUTE}' is OLDER than '${_installPATH}'"
				_doCOPY=false
			fi
		fi
	fi
	# finally check if ~/.dofi exists, if so, we won't create
	[ -d "${_DOFIHOME}" ] && { _debug "${_DOFIHOME} already exists"; _createDOFI=false; }
	# what to do now
	_debug "_seeDOFI=${_seeDOFI}"
	_debug "_doMKDIR=${_doMKDIR}"
	_debug "_doCOPY=${_doCOPY:-unset}"
	_debug "_needPATH=${_needPATH}"
	if [[ ${_doCOPY} = "false" ]]; then
		_info "nothing to do"
		exit
	else
		if [[ ${_doMKDIR} = "true" ]]; then
			# make sure the entire mkdir path can be created
			# function to determine if mkdir will work
			_mkdirTEST () {
				local dir="$1"
				while [ ! -d "$dir" ]; do
					dir=$(dirname "$dir")
				done
				if [ ! -w "$dir" ]; then
					_warn "no write permissions in '$dir'"
					return 1
				fi
			}
			if _mkdirTEST "${_installPATHBASE}"; then
				_debug "can 'mkdir -p' '${_installPATHBASE}'"
			else
				_warn "write permissions do not permit 'mkdir -p ${_installPATHBASE}'"
				_warn "check the path and/or the permissions"
				_error "failed to make '${_installPATHBASE}'"
				exit 1
			fi
		else
			_debug "no need to make a new dir"
		fi
		_debug "mkdir and copy now"
		# we are now fairly certain these will work
		# make the directory and copy the file
		mkdir -p "${_installPATHBASE}"
		cp "${_selfABSOLUTE}" "${_installPATH}"
		_info "new dofi file installed"
	fi
	# now do the PATH work
	if [[ ${_needPATH} = "true" ]] && [[ ${_updatePATH:-} = "true" ]]; then
		_debug "adding '${_installPATHBASE}' to PATH now"
		export PATH=$PATH:${_installPATHBASE}
		_debug "adding '${_installPATHBASE}' to '$HOME/.bashrc' now"
		echo "export PATH=$PATH:${_installPATHBASE}" >> "$HOME/.bashrc"
		_warn "to use dofi, you will need to log off/on to reload PATH..."
		_warn "or source the modified bashrc: 'source ~/.bashrc'"
	elif [[ ${_needPATH} = "true" ]]; then
	#elif [[ ${_needPATH} = "true" ]] && [[ ${_updatePATH:-} = "false" ]]; then
		_warn "you must add '${_installPATHBASE}' to your PATH to use 'dofi'"
	fi
	# now run 'dofi create' if there is no dofi
	if [[ ${_createDOFI:-} = "false" ]]; then
		_debug "skipping dofi create; all done with install"
		exit 0
	else
		_debug "now create the dofi local repo"
		# for our purposes, we use ABSOLUTEPATH because we can
		${_installPATH} create
	fi
}

# HELPER FUNCTIONS

# install the github cli
_installGithubCLI () {
	# beautiful install routine from:
	# https://github.com/cli/cli/blob/trunk/docs/install_linux.md
	(type -p wget >/dev/null || (sudo apt update && sudo apt-get install wget -y)) \
	&& sudo mkdir -p -m 755 /etc/apt/keyrings \
	&& wget -qO- https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg > /dev/null \
	&& sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg \
	&& echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
	&& sudo apt update \
	&& sudo apt install gh -y
}

# check for ssh-agent
_checkSSHAgent () {
	# validate that ssh-agent is running; warn if not
	# do not muck with ssh-agent, warn and exit instead
	# ssh-agent is a hot mess with its startup requirements
	# besides, a user's security is his own business
	timeout .3s ssh-add -l &>/dev/null
	if [ "$?" == 2 ]; then
		# ssh-agent isn't running; warn
		_warn "no ssh-agent running; a running ssh-agent is recommended"
		return 1
	fi
	# TODO improve the discovery here...
}

# ssh-keygen wrapper
_generateSSHKeys () {
	# create unique ssh keypair for dofi authentication to _remotePLATFORM
	# we use the comment to identify the key clearly...long, but unambiguous
	# check for existing keys...and stop if they exst
	_privKEYNAME="dofi-${_USERNAME}-${_selfHOST}-${_remotePLATFORM}-${_remoteUSERNAME}"
	_privKEYPATH="$HOME/.ssh/$_privKEYNAME"
	_pubKEYNAME="dofi-${_USERNAME}-${_selfHOST}-${_remotePLATFORM}-${_remoteUSERNAME}.pub"
	_pubKEYPATH="$HOME/.ssh/$_pubKEYNAME"
	if [ -e ${_privKEYPATH} ]; then
		_warn "key $(_fmt path ${_privKEYNAME}) already exists"
		_ask "replace keys? [y/n] "
		while read -rsn1 _yn; do
			if [[ ${_yn} = "y" ]]; then
				echo
				_danger "replacing the keys cannot be undone!"
				read -r -p "$(_ask "type $(_fmt key indeed) to proceed") " _response
				if [[ ${_response:-} = "indeed" ]]; then
					rm "${_pubKEYPATH}"
					rm "${_privKEYPATH}"
					_info "deleted keypair ${_privKEYNAME}"
					break
				else
					_warn "cannot proceed with '${_response}'"
					_warn "keypair $(_fmt path ${_privKEYNAME}) not removed"
					return 1
				fi
			elif [[ ${_yn} = "n" ]]; then
				echo
				_warn "remove $(_fmt path ${_privKEYNAME}) keypair and try again"
				return 1
			fi
		done
	fi
	# generate new keys
	if [[ ${_sshPassphrase:-} = false ]]; then
		ssh-keygen -t ed25519 -N '' -q -C "${_privKEYNAME}" -f "${_privKEYPATH}" &
		_sshkeygenPID=$!
		_debug "waiting for ssh-keygen (pid:${_sshkeygenPID}) to complete"
		wait ${_sshkeygenPID}
	else
		_debug "tty is $(tty)"
		_debug "unsetting DISPLAY; ssh-add tries to use DISPLAY instead...stupid"
		DISPLAY=
		ssh-keygen -t ed25519 -q -C "${_privKEYNAME}" -f "${_privKEYPATH}" &
		_sshkeygenPID=$!
		_debug "waiting for ssh-keygen (pid:${_sshkeygenPID}) to complete"
		wait ${_sshkeygenPID}
	fi
}

# check for sudo privileges
_checkSudo() {
	# (heuristic, but not exhaustive)
	# return 0 if they seem to exist (an active session)
	# return 1 if user has sudo privileges (but inactive session)
	# return 2 if user has no sudo privileges
	local _sudoReturnCode
	local _errorCode
	_debug "checking for sudo privileges"
	# first try sudo -n with any command...if this returns zero, we are good
	sudo -n date >/dev/null 2>&1
	_sudoReturnCode=$?
	_debug "'sudo -n date' returned ${_sudoReturnCode}"
	# if this returns zero, we return 0
	[ $_sudoReturnCode = 0 ] && return 0
	_debug "no active sudo session detected"
	_debug "testing for sudoers privileges"
	# next use sudo -v, which returns 1 if user is not a valid sudoer
	# we use timeout to kill sudo -v...then capture the timeout return code
	timeout --foreground -k .2 .2 sudo -S -v > /dev/null 2>&1
	_errorCode=$?
	# now match timeout exit code accordingly
	if [[ $_errorCode = 1 ]]; then
		# sudo returned 1, ie user is not in sudoers file
		_warn "user has no sudo privileges"
		return 1
	elif [[ $_errorCode = 124 ]]; then
		# user is in sudoers file (but session is inactive)
		_warn "user has sudo privileges; however session is inactive"
		return 0
	else
		# some other error
		_warn "unexpected error; 'timeout -k .2 .2 sudo -S -v' returned $_errorCode"
		return 1
	fi
}

# clip to allow easy paste with web browser
_clip() {
	# modified version of clip() from https://git.zx2c4.com/password-store/
	# copy the public key file into the clipboard (if possible)
	local _file=$1
  if [[ -n ${WAYLAND_DISPLAY:-} ]]; then
    local clip_cmd=( wl-copy )
    local paste_cmd=( wl-paste -n )
    if [[ ${X_SELECTION:-} == primary ]]; then
      clip_cmd+=( --primary )
      paste_cmd+=( --primary )
    fi
  elif [[ -n ${DISPLAY:-} ]]; then
    local clip_cmd=( xclip -selection "${X_SELECTION:-}" )
    local paste_cmd=( xclip -o -selection "${X_SELECTION:-}" )
	else
		_warn "no clipboard mechanism detected"
		return 1
	fi
	# we have a clipboard facility
	cat "${_pubKEYPATH}" | $clip_cmd
	_debug "public key copied to clipboard"
}

# git wrapper and passthrough
_git () {
	# check if this is a raw git command (ie 'dofi git <etc>')
	if [[ ${_gitPASSTHROUGH:-} = true ]]; then
		_debug "git command is: '${_gitCommand[@]}'"
		# notice we use an array for the git args...quoting problems before
		git --git-dir="${_DOFIHOME}" --work-tree="${_USERHOME}" "${_gitCommand[@]}"
	else
		# otherwise, this is how the script calls git using _git
		git --git-dir="${_DOFIHOME}" --work-tree="${_USERHOME}" "${@}"
	fi
}

# run after positional parameters are processed and before subcommands
_setEnv () {
	# set straight the environment details
	_selfNAME=$(basename "${BASH_SOURCE[0]}")
	_selfABSOLUTE=$(readlink -f "${BASH_SOURCE[0]}")
	_selfBASE=$(dirname "${_selfABSOLUTE}")
	_selfCALL=${0}
	_selfPWD=$(pwd)
	_selfHOST=$(hostname)
	_USERHOME=${HOME}
	_USERNAME=$(whoami)
	_DOFIHOME="${_USERHOME}/.dofi"
	# set _dofiDEVELOPER
	[[ ${_dofiDEVELOPER:-} = "true" ]] || _dofiDEVELOPER=false
	# set _DEBUG
	[[ ${_DEBUG:-} = "true" ]] || _DEBUG=false
	# TODO include _dofiREPO if _dofiDEVELOPER=true
	# print the environment details in _DEBUG mode
	_debug "$(declare -p _selfNAME)"
	_debug "$(declare -p _selfABSOLUTE)"
	_debug "$(declare -p _selfBASE)"
	_debug "$(declare -p _selfCALL)"
	_debug "$(declare -p _selfPWD)"
	_debug "$(declare -p _selfHOST)"
	_debug "$(declare -p _USERHOME)"
	_debug "$(declare -p _USERNAME)"
	_debug "$(declare -p _DOFIHOME)"
	# print the debug value
	_debug "$(declare -p _DEBUG)"
	# print the developer status
	_debug "$(declare -p _dofiDEVELOPER)"
	# print the positional parameters
	_debug "$(declare -p _allParams)"
	_debug "$(declare -p _subCommandParams)"
}

# the main entry point
main () {
	# read the positional parameters
	_getOpts "${@}"
	# set the environment accordingly
	_setEnv
	# print help if no positional parameters found
	[[ -z ${_subCommand:-} ]] && { _printHelp; exit 0; }
	# execute the subCommand
	[[ -n ${_subCommand:-} ]] && eval _${_subCommandParams} || _error "unexpected error '$?'"
}
# prevent this file from being sourced, but warn instead of panic
(return 0 2>/dev/null) && { _error "dofi cannot be sourced"; return; }
# run the main() function
main "${@}"

